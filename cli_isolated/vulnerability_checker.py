from pathlib import Path
from typing import Tuple

from safety_schemas.models import (FileModel, Vulnerability,
                                   VulnerabilitySeverityLabels)

EXIT_CODE_VULNERABILITIES_FOUND = 64


def pluralize(word: str, count: int = 0) -> str:
    """
    Pluralize a word based on the count.

    Args:
        word (str): The word to pluralize.
        count (int): The count.

    Returns:
        str: The pluralized word.
    """
    if count == 1:
        return word

    default = {"was": "were", "this": "these", "has": "have"}

    if word in default:
        return default[word]

    if (
        word.endswith("s")
        or word.endswith("x")
        or word.endswith("z")
        or word.endswith("ch")
        or word.endswith("sh")
    ):
        return word + "es"

    if word.endswith("y"):
        if word[-2] in "aeiou":
            return word + "s"
        else:
            return word[:-1] + "ies"

    return word + "s"


def check_vulnerabilities(
    file_path: Path,
    inspectable_file,
) -> Tuple[FileModel, str]:
    """
    Checks for vulnerabilities in a dependency file and returns a report.

    Args:
        file_path (Path): The path to the processed file.
        inspectable_file: The processed InspectableFile.

    Returns:
        Tuple[FileModel, str]: A FileModel and a string summary of vulnerabilities.
    """
    exit_code = 0
    count_vulns_scanned = 0
    affected_count = 0
    fixes_count = 0
    dependency_vuln_detected = False
    total_resolved_vulns = 0
    count_vulns_scanned += len(inspectable_file.dependency_results.dependencies)

    if exit_code == 0 and inspectable_file.dependency_results.failed:
        exit_code = EXIT_CODE_VULNERABILITIES_FOUND

    dependency_results = inspectable_file.dependency_results
    affected_specifications = dependency_results.get_affected_specifications()
    affected_count += len(affected_specifications)

    # Initialize the string buffer for the output
    output = [""]

    if any(affected_specifications):
        if not dependency_vuln_detected:
            output.append("Dependency vulnerabilities detected:")
            dependency_vuln_detected = True

        msg = f":pencil: [file_title]{file_path}:[/file_title]"
        output.append(msg)

        for spec in affected_specifications:
            # Sort vulnerabilities by severity
            vulns_to_report = sorted(
                [v for v in spec.vulnerabilities if not v.ignored],
                key=lambda v: v.severity.cvssv3.get("base_score", 0)
                if v.severity and v.severity.cvssv3
                else 0,
                reverse=True,
            )
            critical_vulns_count = sum(
                1
                for v in vulns_to_report
                if v.severity
                and v.severity.cvssv3
                and v.severity.cvssv3.get("base_severity", "").lower()
                == VulnerabilitySeverityLabels.CRITICAL.value.lower()
            )

            vulns_found = len(vulns_to_report)
            vuln_word = pluralize("vulnerability", vulns_found)

            msg = f"[dep_name]{spec.name}[/dep_name][specifier]{spec.raw.replace(spec.name, '')}[/specifier]  [{vulns_found} {vuln_word} found"

            if vulns_found > 3 and critical_vulns_count > 0:
                msg += f", [brief_severity]including {critical_vulns_count} critical severity {pluralize('vulnerability', critical_vulns_count)}[/brief_severity]"

            output.append(msg)

            remediation_lines = []
            if spec.remediation.recommended:
                total_resolved_vulns += spec.remediation.vulnerabilities_found

            # Put remediation here
            if not spec.remediation.recommended:
                remediation_lines.append(
                    f"No known fix for [dep_name]{spec.name}[/dep_name][specifier]{spec.raw.replace(spec.name, '')}[/specifier] to fix "
                    f"[number]{spec.remediation.vulnerabilities_found}[/number] "
                    f"{vuln_word}"
                )
            else:
                msg = (
                    f"[rem_brief]Update {spec.raw} to "
                    f"{spec.name}=={spec.remediation.recommended}[/rem_brief] to fix "
                    f"[number]{spec.remediation.vulnerabilities_found}[/number] "
                    f"{vuln_word}"
                )
                if (
                    spec.remediation.vulnerabilities_found > 3
                    and critical_vulns_count > 0
                ):
                    msg += f", [rem_severity]including {critical_vulns_count} critical severity {pluralize('vulnerability', critical_vulns_count)}[/rem_severity] :stop_sign:"

                fixes_count += 1
                remediation_lines.append(f"{msg}")
                if spec.remediation.other_recommended:
                    other = "[/recommended_ver], [recommended_ver]".join(
                        spec.remediation.other_recommended
                    )
                    remediation_lines.append(
                        f"Versions of {spec.name} with no known vulnerabilities: "
                        f"[recommended_ver]{other}[/recommended_ver]"
                    )

            for line in remediation_lines:
                output.append(line)
            output.append(f"Learn more: [link]{spec.remediation.more_info_url}[/link]")

    else:
        output.append(
            f":white_check_mark: [file_title]{file_path}: No issues found.[/file_title]"
        )

    # Prepare and return the FileModel
    file_model = FileModel(
        location=file_path,
        file_type=inspectable_file.file_type,
        results=dependency_results,
    )
    return file_model, "\n".join(output)
